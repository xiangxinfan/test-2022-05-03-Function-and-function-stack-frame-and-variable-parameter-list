#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>


//函数

	//书中所说函数的好处：
//1、降低复杂度
//2、避免重复代码段
//3、限制改动带来的影响
//4、隐含顺序
//5、改进性能
//6、进行集中控制
//7、隐含数据结构
//8、隐含指针操作
//9、隐含全局变量：参数传递

	//函数的基本语法格式
//返回值  函数名 （形参列表）
//{
//	语句构成的代码块
//}
	
	//编码风格
//1、每个函数都需要注释，即使函数短到可能只有几行（有时间可以进行编写）
//2、每个函数定义结束之后以及每个文件结束之后都需要加一个或者若干个空行，便于结构清晰
//3、在函数体内，变量定义与函数语句之间要加空行，还是为了展现出模块的清晰
//4、逻辑上密切相关的语句之间不加空行，其他地方应加空行分隔
//5、复杂的函数中，在分支语句、循环语句结束之后需要适当的注释，方便区分各分支或循环体（这个规则其实在后期
	// 维护代码方面很重要，写的是end of if 或者end of for）
//6、修改别人代码的时候不要轻易删除别人的代码，应该用适当的注释方法
//7、用缩行显示程序结构，使排版整齐，缩进量统一使用4个字符（不建议使用TAB进行缩进，原因是不同的编译器对TAB的定义不同）
//8、在函数体的开始，结构/联合的定义、枚举的定义以及循环、判断等语句中的代码都要采用缩行。
//9、同层次的代码在同层次的缩进层上
//10、代码行最大长度宜控制在80个字符以内，较长的语句、表达式等要分成多行书写
//11、长表达式要在低优先级操作符处划分新行，操作符放在新行之首（以便突出操作符）。拆分出的新行要进行适当的缩进，使排版整齐，语句可读
//12、如果函数中的参数较长，则要进行适当的划分。
//13、用正确的反义词组命名具有互斥意义的变量或相反动作的函数等
//14、如果代码行中的运算符比较多，用括号确定表达式的操作顺序，避免使用默认的优先级
//15、不要编写太复杂的复合表达式
//16、不要有多用途的复合表达式
//17、尽量避免含有否定运算的条件表达式
//18、参数的书写要完整，不要贪图省事只写参数的类型而省略参数名字。如果函数没有参数，则用void填充

	//函数设计的一般原则和技巧
//19、原则上尽量少使用全局变量，因为全局变量的生命周期太长，容易出错，也会长时间占用空间。在多线程运行中容易出现干扰
//20、参数命名要恰当，顺序要合理。函数形参一般都是从右到左
//21、如果你的参数是指针，且仅作输入参数用，则应该在类型前加const（const修饰的是*），以防止该指针在函数体内被意外修改
//22、不要省略返回值的类型，如果函数没有返回值，那么应该声明为void类型。如果缺返回值类型，编译器则默认函数的返回值是int类型的
//23、在函数体的“入口处”，对参数的有效性进行检查。尤其是指针参数，尽量使用assert宏做入口校验，而不使用if语句校验。
//#include <assert.h>
//void show(int* arr, int num)
//{
//	assert(arr);//只有在Debug模式中有效！
//	for (int i = 0; i < num; i++)
//	{
//		printf("arr[%d]:%d\n", i, arr[i]);
//	}
//}
//int main()
//{
//	int arr[] = { 1,2,3,4,5,6,7,8,9 };
//	int num = sizeof(arr) / sizeof(arr[0]);
//	show(arr, num);//这里是可以运行通过的
//	show(NULL, num);//这里程序会直接被终止
//	show(0x123456, num);//这里程序assert是检查不出来的，所以跟上面一样直接被终止
//	return 0;
//}
//Debug:程序是可以直接被调试的
//Release:程序是不可以直接被调试的


//24、return语句不可返回指向“栈内存”的“指针”，因为该内存在函数体结束时被自动销毁
//25、函数的功能要单一，不要设计多用途的函数。
//26、函数体的规模要小，尽量控制在80行代码之内
//27、相同的输入应当产生相同的输出。尽量避免函数带有“记忆”功能。给变量加个static
//28、避免函数有太多的参数，参数个数尽量控制在4个或者4个以内。如果参数太多，在使用时容易将参数类型或顺序搞错
//29、（不推荐但是看情况）尽量不要使用类型和数目不确定的参数
//30、有时候函数不需要返回值，但为了增加灵活性，如支持链式表达，可以附加返回值。
//31、不仅要检查输入参数的有效性，还要检查通过其他途径进入函数体内的变量的有效性，例如全局变量，文件句柄等
//32、函数名与返回值类型在语义上不可突破
//33、汇编语言应该被封装并隔离，最好同时定义成宏
//34、声明或定义一个数组时，它的大小应该是显示声明。一般定义成宏
//35、初始化非零数组和结构体的时候需要用花括号配对
//36、下列条件成立时，整型表达式的值不应该隐式转换为不同的基本类型（转换不是带符号的向更宽整数类型的转换；表达式是复杂表达式；表达式不是常量而是函数参数；表达式不是常量而是返回的表达式）
//37、（不推荐）下列条件成立时，浮点类型表达式的值不应隐式转换为不同的类型：（转换不是向更宽浮点类型的转换；表达式是复杂表达式；表达式是函数参数；表达式是返回表达式）
//38、（不推荐）整型复杂表达式的值只能强制转换到更窄的类型，且与表达式的基本类型具有相同的符号
//39、（不推荐）浮点类型复杂表达式的值，只能强制转换到更窄的浮点类型
//40、函数原型中的指针参数如果不是用于修改所指向的对象，就应该声明为指向const的指针
//41、带有non-void返回类型的函数，其所有退出路径都应具有显式的带的表达式的return语句。void返回值类型的函数不允许使用“return;”语句
//42、对指针和数组的读/写操作，必须要使用sizeof关键字校验其对象的大小
//43、使用memcpy、strcpy等库函数之前，必须先校验目的地址指针是否有效，且判断写入长度
//44、使用strncpy库函数代替strcpy库函数
//45、指针的数学运算只能用在指向同一数组元素的指针上
//46、标准库中保留的标识符、宏和函数，不能被定义、重定义或取消定义
//47、不能重用标准库中宏、对象或函数的名字
//48、传递给库函数的值必须检查其有效性，检测的越多越好
//49、不要使用错误指示errno
//50、不应使用库<stddf.h>中的宏offsetof



	//函数栈帧与可变参数列表

//深刻理解函数调用过程
//学会使用可变参数列表的使用与原理
//深入理解递归（后面是算法思想）（函数递归是有成本的）
//了解命令行参数


	//认识相关寄存器
//eax:通用寄存器，保留临时数据，常用于返回值
//ebx:通用寄存器，保留临时数据
//ebp:栈底寄存器（可以指定一定的内存范围）
//esp:栈顶寄存器
//eip:指令寄存器，保存当前指令的下一条指令的地址


	//认识相关汇编命令
//mov:数据转移指令
//push:数据入栈，同时esp栈顶寄存器也要发生改变
//pop:数据弹出至指定位置，同时esp栈顶寄存器也要发生改变
//sub:减法指令
//add:加法指令
//call:函数调用，1、压入返回地址 （根本原因是函数是可能调用完毕的，就需要返回） 2、转入目标函数
//jump:通过修改eip，转入目标函数，进行调用
//ret:恢复返回地址，压入eip，类似pop eip命令

//int MyAdd(int a, int b)
//{
//	int c = 0;
//	c = a + b;
//	return c;
//}
//int main()
// {
//	int x = 0xA;
//	int y = 0xB;
//	int z = 0;
//	z = MyAdd(x, y);
//	printf("z=%d\n", z);
//	return 0;
//}


//这里要注意的是main函数也是会被调用的函数，main函数会被谁调用，是会被一个叫__tmainCRTStartup用来调用的
//那__tmainCRTStartup是被谁调用的，是被mainCRTStartup来调用的，在mainCRTStartup下面会有一个
//__security_init_cookie();来进行调用的。总的推到来说，main函数最终是会被操作系统来进行调用的


//在空间地址排布中，由低地址到高地址的排布为：
		//代码区，字符常量区，已初始化全局变量，未初始化全局变量，堆区，栈区
//将栈区放大
//地址由下向上依次增加，对于上面的代码，分别为：
		//其他栈区，main函数栈帧，MyAdd的栈帧
//这部分视频在CC talk第28讲，1小时30分钟

//结论：
//1、形成临时变量，是在这个函数被正是调用之前就已经形成了而且是压入栈中的
//2、形参实例化的顺序是从右向左的！！！（这个右左是形参中的右左）

 
//MyAdd的栈帧结构图解在第29讲15分钟左右


//函数的栈帧是自己形成的，在看汇编代码时，有一个减多少，
//这里减多少是由谁决定的？是由编译器决定的，编译器依据什么来决定？？
//在C语言编写中，都是会有类型的!编译器有能力知道所有类型对应定义变量的大小

//在返回过程中，会通过return进行返回， 在汇编语言中就是将ebp移动到exp中，可以理解成释放
//“栈帧”（是双引号的，因为并没有释放完），移动完之后寄存器中的数据依然存在。

//pop是压栈，push是出栈

//栈顶指向的是什么东西呢？？
	//所谓的返回本质
	//1、返回到main函数的栈帧
	//2、返回带有main函数对应的代码


//void bug() {
//	printf("you can see me!\n");
//	Sleep(10000);
//}
//int MyAdd(int a, int b) {
//	printf("MyAdd be called!\n");
//	*(&a - 1) = (int)bug;//减的是所指向类型空间的大小，因为是个指针
//	return 0;
// }
//int main(){
//	int x = 0xA;
//	int y = 0xB;
//	int z = 0;
//	z = MyAdd(x, y);
//	printf("after:%d\n", z);
//	return 0;
//}

//总结栈帧：
//1、调用函数，需要先形成临时拷贝，形成过程是从右向左的
//2、临时空间的开辟，是在对应函数栈帧内部开辟的
//3、函数调用完毕，栈帧结构被释放掉（通过mov）
//4、临时变量具有临时性的本质：栈帧具有临时性
//5、调用函数是有成本的，成本体现在时间和空间上，本质是形成和释放栈帧有成本
//6、函数调用，因拷贝所形成的临时变量，变量和变量之间的位置关系是有规律的



//可变参数列表


//这是形参，函数调用发生形参实例化，就会发生拷贝，放在这个函数的栈帧之中，从右向左
// 参数的初始化是从右向左的
//int GetMax(int x, int y) {
//	if (x > y) {
//		return x;
//	}
//	else {
//		return y;
//	}
//
//}
//int main() {
//	int x = 0;
//	int y = 0;
//	scanf("%d%d", &x, &y);
//	int max = GetMax(x, y);
//	printf("max=%d\n", max);
//	return 0;
//}

//求一组数据的较大值，但是这组数据不确定，可能有10个8个，也可能有20个50个
//scanf和printf是最常见的可变参数列表函数

////如果出现5个参数呢，三个参数呢，这就出现了同样的需求，相同的代码出现了代冗余
//int FindMax(int num, int x1, int x2, int x3, int x4)
//{
//
//}

//所以可以进行下面这样写：
//int FindMax(int num, ...)//这个就是可变参数列表
//{
//
//}
//使用可变参数列表，首先要会使用三个宏

//num表示传入参数的个数
//int FindMax(int num, ...)//这个就是可变参数列表
//{
//	va_list arg;//定义可以访问可变参数部分的变量，其实是一个char*类型
//	va_start(arg, num);//使arg指向可变参数部分
//	va_end(arg);//arg使用完毕，收尾工作。本质上就是讲arg指向NULL
//}

//结论：可变参数列表,至少要有一个明确参数！

//#include <stdarg.h>
//int FindMax(int num, ...)//这个就是可变参数列表
//{
//	va_list arg;//定义可以访问可变参数部分的变量，其实是一个char*类型
//	va_start(arg, num);//使arg指向可变参数部分
//	
//	int max = va_arg(arg, int);//根据类型，获取可变参数列表中的第一个数据
//	for (int i = 0; i < num - 1; i++) {//回去并比较其他的
//		int x = va_arg(arg, int);
//		if (max < x) {
//			max = x;
//		}
//	}
//	va_end(arg);//arg使用完毕，收尾工作。本质上就是讲arg指向NULL
//	return max;
//}
//int main()
//{
//	int	max = FindMax(5, 1, 2, 8, 6, 4);//函数传参一定会进行临时拷贝，这部分临时拷贝是在栈帧这部分进行临时拷贝的
//	printf("max=%d\n", max);
//	return 0;
//}

 //临时变量具有临时性的原因：函数调用形成栈帧，函数返回释放栈帧


//结论:
//1、如果函数没有形式参数，可以给函数传递参数吗？ 
	//答案是肯定的
//2、在C中，只要发生了函数调用并且传递了参数，必定形成临时变量
//3、所谓的临时拷贝本质就是在栈桢内部形成的，从右向左一次形成临时拷贝（变量）说明
	//入参数的时候 ：最右侧的数据是先入栈的

//#include <stdarg.h>
//int FindMaxData(int num, ...)//至少要有一个明确的参数
//{
//	va_list arg;//类型是char*的
//	va_start(arg, num);
//	int max = va_arg(arg, int);//指向了arg部分，每部分根据int来提取
//	//int max=va_arg(arg,char);//这是不正确的，原因是
//	//在可变参数中，如果是短整型，一般都要进行int类型（4字节）进行类型提升
//	//所以用char是不正确的，在汇编中已经进行4字节的类型提升已经成了整形
//	//进行对齐的时候就是用4字节进行对齐，向上取整 
//	for (int i = 1; i < num; i++)
//	{
//		int curr = va_arg(arg, int);
//		if (curr > max) {
//			max = curr;
//		}
//	}
//	va_end(arg);//本质上就是va_end将arg置为0
//	return max;
//}
//int main()
//{
//	int max = FindMaxData(5, 11, 21, 31, 51, 41);
//	printf("max=%d\n", max);
//	return 0;
//}


//通过查看汇编，我们看到，在可变参数场景下：
//1、实际传入的参数如果是char,short,float,编译器在编译的时候，会自动进行提升（通过查看汇编，就可以看到）
//2、函数内部使用的时候，根据类型提取数据，更多的是通过int或者double来进行

//注意事项：
	//1、可变参数必须从头到尾诸葛访问。如果你再访问了几个可变参数之后想半途终止，
// 这是可以的,但是，如果你想一开始就访问参数列表中间的参数，那是不行的
	//2、参数列表中至少有一个命名参数。如果连一个命名参数都灭有，就无法使用va_start
	//3、这些宏是无法直接判断实际存在参数的数量
	//4、这些宏无法判断每个参数的类型
	//5、在如果在va_arg中指定了错误的类型，那么其后果是不可预测的

//原理：
	//1、可变参数列表对应的函数，最终调用也是函数调用，也要形成栈帧
	//2、栈帧形成前，临时变量是要先入栈的，根据之前所学，参数之间位置关系都是固定的
	//3、通过上面汇编的学习，发现了短整型在可变参数部分，会默认进行整型提升，那么函数
//内部在提取该数据的时候，就要考虑提升之后的值，如果不加考虑，获取数据可能会报错或者
//结果不正确

//下面这行代码可能与编译器有关系，有些字符可能不一样，但是大概的意思都是相同的
//#define _crt_va_arg(ap,t) (*(t*)((ap += INTSIZEOF(t)) - INTSIZEOF(t))))

//1、把“当前元素”提取出来
//2、arg指向下一个待访问元素

//(*(t*)通过强制转化，提取出符合类型大小的数据

//部分详细内容，在函数栈帧于可变参数列表中的PDF中



//命令行参数
/*
	main函数也是一个函数，其实也可以携带参数的
	int main(int argc, char *argv[], char* envp[])
	{
		program-statements
	}
*/
//那这里是有三个参数的


//第一个参数：argc是个整型变量，表示命令行参数的个数（含第一个参数）
//第二歌参数：argv是个字符指针的数组，每个元素是一个字符指针，指向一个字符串。
	//这些字符串就是命令行中的每一个参数（字符串）。
//第三个参数：envp是字符指针的数组，数组的每一个源元素是一个指向一个环境变量
	//（字符串）的字符指针


//int main(int argc, char* argv[], char* env[])
//{
//	for (int i = 0 ; i < argc; i++) {
//		printf("argv[%d]:%s\n", i, argv[i]);
//	}
//	return 0;
//}
//这种打印出来是exe文件的就是命令行参数



//总结：
//1、调用函数，需要先形成临时拷贝，形成过程是从右向左的
//2、临时空间的开辟，是在对应函数栈帧内部开辟的
//3、函数调用完毕，栈帧结构被释放掉
//4、临时变量具有临时性的本质：栈帧据偶临时性
//5、调用函数是有成本的，成本体现在时间和空间上，本质是形成和释放栈帧有成本
//6、函数调用，因拷贝所形成的临时变量，变量和变量之间的位置关系是有规律的


 
//递归

//1、递归本质也是函数调用，是函数调用，本质上就要形成和释放栈帧
//2、根据栈帧的学习，调用函数是有成本的，这个成本就体现在形成和释放栈帧上：时间+空间
//3、所以，递归就是不断形成栈帧的过程
//理论认识
//1、内存和CPU的资源是有限的，也就决定了，合理的递归是绝对不能无限递归下去
//2、递归不是什么时候都能用，而且要满足自身的应用场景，即：目标问题的子问题，也可以
// 采用相同的算法，本质就是分治的思想

//3、核心思想：大事化小+递归出口 



//1、函数创建的时候，是被调用的，当然，也可以调用别人
//2、函数是可以自己调用自己的，包括main函数
//3、递归分为合法递归和非法递归
	//非法递归：是没有递归出口的
	//合法递归：都是函数调用，调用就在开辟栈帧，开辟就会消耗资源（函数递归是有
	// 成本的：时间+空间）
//这里就直接决定内存（栈）的大小是有限的，也就决定：合法递归一定是有限次递归



//这个例子说明概念：
//不使用临时变量，求字符串长度

//int MyStrlen(const char* s)
//{
//	if ('\0' == *s)//就是*s == '\0'
//	{
//		return 0;
//	}
//	return MyStrlen(++s) + 1;
//}
//int main()
//{
//	const char* str = "abcdefg123456";
//	int len = MyStrlen(str);
//	printf("len:%d\n", len);
//	return 0;
//}


//递归：
	//1、语法+基本使用=>鹏哥C语言+C深剖
	//2、刷题+分治算法思想+递归形成的数据结构（二叉树）

 //这个例子说明性质

//#include <assert.h>
//int MyStrlen(const char* s)
//{
//	assert(s);
//	return *s ? (MyStrlen(++s) + 1) : 0;
//}
//int main()
//{
//	const char* str = "abcdefg123456";
//	int len = MyStrlen(str);
//	printf("len:%d\n", len);
//	return 0;
//}

//注：assert就是一个判断条件的宏


//斐波那契数列

//递归算法

//int Fib(int n)
//{
//	if (1 == n || 2 == n)
//	{
//		return 1;
//	}
//	return Fib(n - 1) + Fib(n - 2);
//}
//int main()
//{
//	int n = 5;
//	int x = Fib(n);
//	printf("Fib(%d):%d\n", n, x);
//
//	//或者
//	printf("Fib(%d):%d\n", 10, Fib(10));
//	return 0;
//}


//计算递归的时间
//#include <windows.h>//包含该头文件，才能使用win提供的GetTickCount()函数，来获取开机
//					//到现在的累计时间,此处用它，原因是简单
//int Fib(int n)
//{
//	if (1 == n || 2 == n)
//	{
//		return 1;
//	}
//	return Fib(n - 1) + Fib(n - 2);
//}
//int main()
//{
//	int n = 41;
//	double start = GetTickCount();
//	int x = Fib(n);
//	double end = GetTickCount();
//	printf("Fib(%d):%d\n", n, x);
//	printf("%.1f s\n", (end - start) / 1000);//单位是毫秒，转换成秒
//	return 0;
//}

//递归计算：
//1、随着计算量的变大，递归成本越来越搞
//2、具体：树形结构越来越高，并且里面存在大量的重复计算
		//大量重复：计算过程是通过函数调用完成的
		//函数调用是要形成栈帧的，形成栈帧是有成本的（时间+空间）

//大量重复计算进行一下简单测试：
 
//#include <windows.h>
//int count = 0;
//int Fib(int n)
//{
//	
//	if (1 == n || 2 == n)
//	{
//		return 1;
//	}
//	if (3 == n)
//	{
//		count++; 
//	}
//	return Fib(n - 1) + Fib(n - 2);
//}
//int main()
//{
//	int n = 41;
//	double start = GetTickCount();
//	int x = Fib(n);
//	double end = GetTickCount();
//	printf("Fib(%d):%d\n", n, x);
//	printf("%.1f s\n number=%d\n", (end - start) / 1000,count++);//单位是毫秒，转换成秒
//	return 0;
//}


//函数调用是有成本的！递归不一定适合所有场景，尤其是对效率或者资源需求量大的场景
//重复计算，意味着重复调用，重复调用意味着重复形成栈帧，创建与释放栈帧，是有成本的

////用非递归的方式处理斐波那契数列
//#include <stdlib.h>
//int Fib(int n)
//{
//	//申请空间保存中间数据
//	int* dp = (int*)malloc(sizeof(int) * (n + 1));
//	if (NULL == dp) {
//		return -1;
//	}
//	//条件初始化
//	dp[1] = 1;
//	dp[2] = 1;
//	for (int i = 3; i <= n; i++)
//	{
//		//动态规划
//		dp[i] = dp[i - 1] + dp[i - 2];
//	}
//	int ret = dp[n];
//	free(dp);
//	return ret;
//}
//int main()
//{
//	int n = 42;
//	double start = GetTickCount();
//	int x = Fib(n);
//	double end = GetTickCount();
//	printf("fib(%d):%d\n", x, n);
//	printf("%lf s\n", (end - start) / 1000);
//	return 0;
//}

//为什么循环或者迭代方案，效率就高呢？

//迭代法，本质是因为没有多余的函数调用

////第三种写法：
//int Fib(int n)
//{
//	int first = 1;
//	int second = 1;
//	int third = 1;
//	while (n>=3)
//	{
//		third = second + first;
//		first = second;
//		second = third;
//		n--;
//	}
//	return third;
//}
//int main()
//{
//	int n = 42;
//	double start = GetTickCount();
//	int x = Fib(n);
//	double end = GetTickCount();
//	printf("fib(%d):%d\n", n, x);
//	printf("%lf s\n", (end - start) / 1000);
//	return 0;
//}

//这种办法只有一种栈帧，就是fib，相比于迭代就是更省空间

//递归与迭代区别

//递归：
	//1、效率一般不是特别高
	//2、代码简单
//迭代
	//1、效率一般很高
	//2、代码一般比较复杂

//这两种比较主要是为了合理使用递归，不同问题不同对待 